<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>VR Model Viewer</title>
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        background: #000;
        color: #fff;
      }
      #app {
        position: fixed;
        inset: 0;
      }
      .overlay {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;
      }
      .loader {
        width: 240px;
        background: rgba(255, 255, 255, 0.15);
        height: 8px;
        border-radius: 6px;
        overflow: hidden;
      }
      .bar {
        height: 100%;
        width: 0%;
        background: #fff;
      }
      .hud {
        position: fixed;
        top: 12px;
        right: 12px;
        display: flex;
        gap: 8px;
      }
      .hud button {
        background: rgba(255, 255, 255, 0.9);
        color: #000;
        border: 0;
        border-radius: 6px;
        padding: 6px 10px;
        font-size: 12px;
        cursor: pointer;
      }
      .hud select {
        background: rgba(255, 255, 255, 0.9);
        color: #000;
        border-radius: 6px;
        padding: 4px 8px;
        font-size: 12px;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <div class="overlay" id="overlay" aria-hidden="true">
      <div>
        <div class="loader"><div class="bar" id="bar"></div></div>
        <div
          id="label"
          style="
            margin-top: 8px;
            text-align: center;
            font-size: 12px;
            opacity: 0.9;
          "
        >
          Loading…
        </div>
      </div>
    </div>
    <div class="hud" id="hud" style="display: none">
      <button id="fit">Fit</button>
      <button id="rot">Rotate</button>
      <select id="env">
        <option value="none">Env: none</option>
        <option value="city">Env: city</option>
        <option value="sunset">Env: sunset</option>
        <option value="forest">Env: forest</option>
        <option value="studio">Env: studio</option>
      </select>
    </div>
    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.155.0/build/three.module.js";
      import { OrbitControls } from "https://unpkg.com/three@0.155.0/examples/jsm/controls/OrbitControls.js";
      import { VRButton } from "https://unpkg.com/three@0.155.0/examples/jsm/webxr/VRButton.js";
      import { GLTFLoader } from "https://unpkg.com/three@0.155.0/examples/jsm/loaders/GLTFLoader.js";
      import { RGBELoader } from "https://unpkg.com/three@0.155.0/examples/jsm/loaders/RGBELoader.js";

      const params = new URLSearchParams(location.search);
      let modelUrl = params.get("src") || params.get("model") || "";
      try {
        if (modelUrl.includes("%2F")) modelUrl = decodeURIComponent(modelUrl);
      } catch {}
      const app = document.getElementById("app");
      const overlay = document.getElementById("overlay");
      const bar = document.getElementById("bar");
      const label = document.getElementById("label");
      const hud = document.getElementById("hud");

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.01,
        1000,
      );
      camera.position.set(0, 0.8, 2.5);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: false,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.xr.enabled = true;
      app.appendChild(renderer.domElement);
      document.body.appendChild(VRButton.createButton(renderer));

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      const ambient = new THREE.AmbientLight(0xffffff, 0.7);
      scene.add(ambient);
      const dir = new THREE.DirectionalLight(0xffffff, 1.0);
      dir.position.set(1.5, 2.5, 1.8);
      scene.add(dir);

      // Environment preset loader (HDRs from pmrem gen) — optional quick presets
      const envPresets = {
        none: null,
        city: "https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/canary_wharf_2_1k.hdr",
        sunset:
          "https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/sunset_in_the_chalk_quarry_1k.hdr",
        forest:
          "https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/forest_slope_1k.hdr",
        studio:
          "https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_03_1k.hdr",
      };
      const pmrem = new THREE.PMREMGenerator(renderer);
      async function applyEnv(name) {
        const url = envPresets[name];
        if (!url) {
          scene.environment = null;
          scene.background = new THREE.Color(0x000000);
          return;
        }
        const hdr = await new RGBELoader().loadAsync(url);
        const tex = pmrem.fromEquirectangular(hdr).texture;
        hdr.dispose?.();
        scene.environment = tex;
        scene.background = new THREE.Color(0x000000);
      }

      const root = new THREE.Group();
      scene.add(root);
      let pivot = new THREE.Group();
      root.add(pivot);

      function fitToView(object) {
        const box = new THREE.Box3().setFromObject(object);
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());
        object.position.sub(center); // center model at origin
        const maxDim = Math.max(size.x, size.y, size.z) || 1;
        const target = 1.2; // target size in scene units
        const scale = target / maxDim;
        object.scale.setScalar(scale);
        const dist = (target / Math.tan((camera.fov * Math.PI) / 360)) * 1.6;
        camera.position.set(0, target * 0.4, dist);
        controls.update();
      }

      async function loadModel(url) {
        return new Promise((resolve, reject) => {
          const loader = new GLTFLoader();
          loader.load(
            url,
            (gltf) => resolve(gltf.scene),
            (evt) => {
              if (evt.lengthComputable) {
                const pct = Math.max(
                  1,
                  Math.round((evt.loaded / evt.total) * 100),
                );
                bar.style.width = pct + "%";
                label.textContent = `Loading ${pct}%`;
              }
            },
            (err) => reject(err),
          );
        });
      }

      function showHUD() {
        hud.style.display = "flex";
      }
      function hideOverlay() {
        overlay.style.display = "none";
      }

      // Controls UI
      document.getElementById("fit").onclick = () => fitToView(pivot);
      let rotating = true;
      document.getElementById("rot").onclick = () => {
        rotating = !rotating;
      };
      document.getElementById("env").onchange = (e) => applyEnv(e.target.value);

      // Load flow
      try {
        const sceneNode = await loadModel(modelUrl);
        pivot.add(sceneNode);
        fitToView(pivot);
        hideOverlay();
        showHUD();
      } catch (e) {
        label.textContent = "Failed to load model";
      }

      renderer.setAnimationLoop(() => {
        if (rotating) pivot.rotation.y += 0.003;
        controls.update();
        renderer.render(scene, camera);
      });

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
